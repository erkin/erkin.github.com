<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="title"
          content="Family spaghetti of programming languages"/>
    <meta name="author"
          content="Erkin B Altunbaş"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, user-scalable=yes"/>

    <link rel="canonical"
          href="https://erkin.party/blog/190208/spaghetti"/>

    <!-- Favicon stuff -->
    <link href="/images/favicons/apple-touch-icon.png"
          rel="apple-touch-icon" sizes="180x180"/>
    <link href="/images/favicons/favicon-32x32.png"
          rel="icon" type="image/png" sizes="32x32"/>
    <link href="/images/favicons/favicon-16x16.png"
          rel="icon" type="image/png" sizes="16x16"/>
    <link href="/images/favicons/site.webmanifest"
          rel="manifest"/>
    <link href="/images/favicons/safari-pinned-tab.svg"
          rel="mask-icon" color="#6e6e6e"/>
    <link href="/images/favicons/favicon.ico"
          rel="shortcut icon"/>

    <meta name="msapplication-TileColor"
          content="#000000"/>
    <meta name="msapplication-config"
          content="/images/favicons/browserconfig.xml"/>
    <meta name="theme-color"
          content="#000000"/>

    <link rel="stylesheet" href="/blog.css"/>

    <title>Family spaghetti of programming languages</title>
  </head>

  <body>
    <article>
      <header>
        <h1>Family spaghetti of programming languages</h1>
        <p>
          <b>Created:</b>
          <time>2019-02-08</time>
          <br/>
          <b>Updated:</b>
          <time>2019-02-10</time>
        </p>
        <hr/>
        <a href="../..">← Back to index</a>
      </header>

      <p>
        This is my attempt at making a family tree of programming languages.
        (It's technically a directed acyclic graph.)
        Notably absent are certain multiparadigm languages, such as Java.
      </p>

      <figure>
        <a href="genealogy.png">
          <img src="genealogy_thumb.png"
               title="Click to view the larger version."
               alt="An extremely convoluted graph."
               style="width:100%"/>
        </a>
        <figcaption>
          Last version.
        </figcaption>
      </figure>

      <aside>
        <p>
          <a href="fp.gv" type="text/vnd.graphviz">Here</a>'s the source code.
          I'm sure it's full of mistakes, so please just send fixes, patches
          and errata to
          <code>% base64 -d &lt;&lt;&lt; 'bWFpbHRvOm1lQGVya2luLnBhcnR5'</code>
          and I'll update this post.
          Also you'll notice that the splines take absurdly roundabout ways in
          the graph. That's Graphviz doing its best at making sense of this
          humongous mess. If you know of a better way to do it, let me know.
        </p>

        <p>
          <b>Errata:</b> I'd like to thank
          <ul>
            <li>
              Thra11 from Lobste.rs for pointing out that D descends
              from C++, not C.
            </li>
            <li>
              Marc Paquette for pointing out that I should include ABC
              as a Python influence and letting me use his research on
              shell genealogy.
              (See below.)
            </li>
            <li>
              Jonatan Andersson for pointing out that Newsqueak is not
              a Smalltalk language.
            </li>
            <li>
              Rainer Joswig for pointing out that Logo is older than
              Scheme, correcting me about XLISP versions and sending me
              a helpful graph on the history of Lisp dialects.
              (See below.)
            </li>
          </ul>
        </p>
      </aside>

      <hr/>

      <h2>Background</h2>
      <p>
        There are a lot of programming languages. A lot.
        <a href="https://rosettacode.org">Rosetta Code</a> lists
        <a href="https://www.rosettacode.org/wiki/Category:Programming_Languages">
        714 of them</a>, as of the date of this post. Just like human languages,
        it's really difficult to map them on family trees, because they
        continuously evolve and have numerous dialects of varying mutual
        intelligibility, informal dialects, different incompatible versions and
        divergent implementations.
      </p>

      <p>
        However, unlike natural languages, programming languages have a
        significantly more problematic property that makes them nigh impossible
        to cleanly reduce into pretty graphs: They're arbitrarily constructed. A
        natural language simply descends from a previous language, and languages
        form trees. Of course, interlanguage influence is widespread (and let's
        not forget that there are pidgins, creoles and, of course, constructed
        languages). Even then, it's still perfectly possible (if not feasible)
        to trace each language's ancestor back.
      </p>

      <p>
        The reason tracing genealogical roots is infeasible in software is
        simply because we "unorganically" take various influences from here and
        there and sculpt a whole new project. This gets especially more
        problematic with newer multi-paradigm languages that borrow something
        from everyone! Whilst borrowing a few words from another language
        doesn't align a natural language's lineage, borrowing a considerable
        amount of semantics or syntax from another language completely alters a
        programming language's lineage.
      </p>

      <p>
        For instance, ask yourself: Where does Python come from? Graphs I found
        online gave me various ridiculous answers, such as C, Perl and even
        Java. Of course, you say to yourself, the answer is ABC, right? CLU?
        Not quite. How about Rust? Where does it come from? The answer is,
        unfortunately, a bit of everything.
      </p>

      <p>
        Last year, August, I was chatting with my
        friend <a href="https://baturin.org">Daniil</a>
        (who's also proofreading this blogpost right now)
        on IRC and he showed me the blogpost he was working on, an
        <a href="https://blog.baturin.org/introduction-to-ocaml.html">
          Introduction to OCaml</a>. He had made a very simple family tree of the
        three main functional programming language families from which all else
        descends. (I exaggerate, but you get my point.)
      </p>

      <figure>
        <a href="dan_genealogy.png">
          <img src="dan_genealogy.png"
             alt="A tree depicting three groups"
             style="width:100%"/>
          </a>
        <figcaption>
          Dan's functional programming family tree
        </figcaption>
      </figure>

      <p>
        I thought that was fascinating. I tried to find similar graphs but, much
        to my chagrin, they were all either way too reductionistic, or, well,
        seemed to have strange preconceptions about what defines a
        language (see notes below). Hard to blame them, really.
      </p>

      <p>
        Instead of taking such an approach, I tried to go by what the languages'
        respective users (or enthusiasts, in case of historic languages) go by
        and set out to make my very own incomplete and sloppy graph.
      </p>

      <figure>
        <a href="genealogy_old.png">
          <img src="genealogy_old_thumb.png"
               title="Click to view the larger version."
               alt="A very convoluted graph."
               style="width:100%"/>
        </a>
        <figcaption>
          The original beauty of a bowl of saucy spaghetti.
        </figcaption>
      </figure>

      <p>
        Unfortunately, I gave up halfway through and mothballed it in a single
        Graphviz dot file and completely forgot about it by October.
      </p>

      <p>
        Just today, I rediscovered it in the random junk I had stashed in
        <a href="gopher://suika.erkin.party/1/files">my gopherspace</a>.
        I brought it up in
        <a href="ircs://freenode.net/#lobsters"><code>#lobsters</code></a>
        and talked about how I made it. Much to my surprise, people encouraged
        me to make a blogpost out of it. So, there you go.
      </p>

      <h2>Methodology</h2>
      <p>
        You can probably guess that I'm not well-versed in a good portion of
        these languages, nor their historical backgrounds. I picked the most
        straightforward method and simply asked people who are and consulted the
        mighty information superhighway when that failed. Wikipedia has
        "influences" and "influenced" sections in infoboxes of programming
        language articles, just like those of artists and
        philosophers. Unfortunately, it's rather lax about what can be
        considered influences, so I had to narrow it down a bit with independent
        research. Languages that openly describe themselves as being based on a
        single language are the best in this aspect.
      </p>

      <p>
        I considered design choices as of the language's birth more important
        than later additions, even if they were slowly eclipsed by foreign
        influences in later versions.
        In the end, I ended up including many insignificant languages and
        excluding equally many significant languages.
      </p>

      <h2>A few notes</h2>
      <h3>Lisps</h3>
      <p>
        Is Lisp a single language? Are the fragmented Lisp "dialects" from Lisp
        Machine era separate languages? Are CLOS and Loops languages at all, as
        some graphs insinuate?
        Is Racket a Scheme implementation or a Scheme-based language on its own?
        (Of course, there are no single answers to these questions. After all,
        <a href="https://en.wikipedia.org/wiki/A_language_is_a_dialect_with_an_army_and_navy">
          a language is a dialect with an army and fleet</a>!)
      </p>

      <p>
        Honestly, Lisp was especially problematic, as most recent Lisps can be
        said to descend from Common Lisp and Scheme at the same time, which
        tells you nothing at all. For instance, PicoLisp and Carp are
        pigeonholed into descending from Common Lisp, but they're actually
        completely independent projects.
        <b>Edit:</b> I ended up attaching them to the now-generic "Lisp" node.
      </p>

      <p>
        Rainer Joswig sent me
        <a href="https://www.dreamsongs.com/Files/Hopl2Slides.pdf">
        this immensely helpful graph</a> on Lisp genealogy, which I might use
        to rewrite the this branch later on.
      </p>

      <h3>Basics</h3>
      <p>
        This was the simplest one and it contains the least significant
        dialects of any family.
        Basic vendors were very straightforward about taking a dialect and
        expanding on it, fitting it to their own equipment and shipping it as
        is.
      </p>

      <h3>Shells</h3>
      <p>
        This was the most painful one. There's a myriad of different Unix shell
        implementations out there with completely varying degrees of
        compatibility and it's nigh-impossible to map them into a neat tree.
        So I ended up pruning away 80% of it in the end.
      </p>

      <p>
        Later, I used portions of Marc Paquette's
        <a href="https://github.com/marcpaq/shellancestry">shell ancestry</a>
        project to rewrite this portion, with various modifications.
        Thanks Marc!
      </p>

      <p>
        <small>
        Both images and the source file are licensed under
        <a href="https://creativecommons.org/licenses/by-sa/4.0/">
          CC-BY-SA 4.0</a>.
        </small>
      </p>
    </article>

    <footer>
      <p>
        <a href="#top">↑ Back to top</a>
        <br/>
        <a href="/blog/">← Back to blog</a>
      </p>
      <hr/>
      <details>
        <summary><small>&copy; 2019 Erkin Batu Altunbaş</small></summary>
        <p>
          <small>
            Permission is granted to make and distribute verbatim copies
            of this entire document without royalty provided the
            copyright notice and this permission notice are preserved.
          </small>
        </p>
      </details>
      <br/>
      <a href="https://erkin.party/emacs/">
        <img src="/images/emacs/powered1.jpg"
             title="Powered by GNU Emacs, the environmentally friendly editor!"
             alt="[Powered by GNU Emacs]"/></a>
        <a href="https://lynx.invisible-island.net/">
          <img src="/images/cheesy/lynx/paula.gif"
               title="Lynx Friendly"
               alt="[Dehanced for Lynx!]"/></a>
    </footer>
  </body>
</html>
