#+TITLE: Family spaghetti of programming languages
#+AUTHOR: Erkin Batu Altunba≈ü
#+DATE: 2019-02-08
#+LANGUAGE: en

This is my first ever blog post so I hope I don't ramble too much. /ahem/

There are a lot of programming languages. A lot. [[https://rosettacode.org][Rosetta Code]] lists [[https://www.rosettacode.org/wiki/Category:Programming_Languages][714 of them]],
as of the date of this post. Just like human languages, it's really difficult to
map them on family trees, because they  continuously evolve and have numerous
dialects of varying mutual intelligibility, informal dialects, different
incompatible versions and divergent implementations.

However, unlike natural languages, programming languages have a significantly
more problematic property that makes them nigh impossible to cleanly reduce into
pretty graphs: They're arbitrarily constructed. A natural language simply
descends from a previous language, and languages form trees. Of course,
interlanguage influence is widespread (and let's not forget that there are
pidgins, creoles and, of course, constructed languages). Even then, it's still
perfectly possible (if not feasible) to trace each language's ancestor back.

The reason tracing geneological roots is infeasible in software is simply
because we "unorganically" take various influences from here and there and
sculpt a whole new project. This gets especially more problematic with newer
multi-paradigm languages that borrow something from everyone! Whilst borrowing a
few words from another language doesn't align a natural language's lineage,
borrowing a considerable amount of semantics or syntax from another language
completely alters a programming language's lineage.

For instance, ask yourself: Where does Python come from? Graphs I found online
gave me various ridiculous answers, such as C, Perl and even Java. Of course,
you say to yourself, the answer is CLU, right? Not quite. How about Rust? Where
does it come from? The answer is, unfortunately, a bit of everything.

Still, I thought to myself, it sure would be nice to see even a sloppy graph,
showing maybe *just* the direct influences. It would be simpler if I just didn't
include languages like Java.

Last year, August, I was chatting with my friend [[https://baturin.org][Daniil]] on IRC and he showed me the
blogpost he was working on, an [[https://blog.baturin.org/introduction-to-ocaml.html][Introduction to OCaml]]. He had made a very simple
family tree of the three main functional programming language families from
which all else descends. (I exaggerate, but you get my point.)

#+CAPTION: Dan's functional programming family tree
[[./dan_geneology.png]]

I thought that was fascinating. I tried to find similar graphs but, much to my
chagrin, they were all either way too reductionistic, or, well, seemed to have
strange preconceptions about what defines a language. Hard to blame them, really.

Instead of taking such an approach, I tried to go by what the languages'
respective users (or enthusiasts, in case of historic languages) go by and set
out to make my very own incomplete and sloppy graph.

#+CAPTION: The beauty of a bowl of saucy spaghetti
[[./geneology.png]]

Unfortunately, I gave up halfway through and mothballed it in a single Graphviz
dot file and completely forgot about it by October.

Just today, I discovered it in the random junk I had stashed in [[http://suika.erkin.party/1/files][my gopherspace]].
I brought it up in [[http://freenode.net/#lobsters][=#lobsters=]] and talked about how I made it. Much to my
surprise, people encouraged me to make a blogpost out of it so I'll try to
describe what I remember from making this.

#+CAPTION: Simplified by diking out secondary influences that stretch the whole graph
[[./geneology_simple.png]]

* Methodology
You can probably guess that I'm not well-versed in a good portion of these
languages, nor their historical backgrounds. I picked the most straightforward
method and simply asked people who are and consulted the mighty information
superhighway when that failed. Wikipedia has "influences" and "influenced"
sections in infoboxes of programming language articles, just like those of
artists and philosophers. Unfortunately, it's rather lax about what can be
considered influences, so I had to narrow it down a bit with independent
research.

I considered design choices as of the language's birth more important than later
additions, even if they were slowly eclipsed by foreign influences in later
versions.

** Lisps
Let's take Lisp. Is Lisp a single language? Are the fragmented Lisp
"dialects" from Lisp Machine era separate languages? Are CLOS and Loops
languages at all? Is Racket a Scheme implementation or a Scheme-descended
language on its own?
(Of course, there are no single answers to these questions. After all,
[[https://en.wikipedia.org/wiki/A_language_is_a_dialect_with_an_army_and_navy][a language is a dialect with an army and fleet]]!)

Honestly, Lisp was especially problematic, as most recent Lisps can be said to
descend from Common Lisp and Scheme at the same time, which tells you nothing at
all.

** Basics
This was the simplest one.

** Shells
This was the most painful one. There's a myriad of different Unix shell
implementations out there with completely varying degrees of compatibility and
it's nigh-impossible to map them into a neat tree.


Both images and the source file are licensed under [[https://creativecommons.org/licenses/by-sa/4.0/][CC-BY-SA 4.0]].
